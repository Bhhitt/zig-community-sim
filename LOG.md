# Development Log

## 2025-04-18 — Food Regrowth Granularity, Config, and Output Cleanup
- Made `food_regrow_chance` a float (f32) for fine-grained control; can now set to very small probabilities (e.g., 0.0001)
- All food/hunger parameters are now easily configurable in `src/core/config.zig`
- Food is now visualized as yellow cells in the GUI
- Removed debug/"cringe" output from the renderer for a clean terminal

## 2025-04-18 — Smooth Subcell Agent Movement
- Agents now move and render with true floating-point positions, allowing for smooth, sub-cell movement across the map.
- Rendering logic in `sdl_renderer.zig` updated to use floating-point coordinates for agent positions (no more box-to-box snapping).
- All agent movement, collision, and boundary logic updated for floating-point precision.
- Visual experience is now much more fluid and natural.

## 2025-04-18
- Agent positions are now floating-point for smooth, sub-cell movement.
- Increased default agent speed to 0.7 cells/tick for more dynamic simulation.
- Energy is always consumed on any movement attempt (including failed/fractional moves).
- Builder's base energy cost reduced and tendency_to_stay lowered for better movement and survival.
- Integration and movement tests updated for floating-point logic and now pass.
- Integration tests now use a distance check for agent movement and allow rare agent deaths (>=4/6 must survive).
- Debug output in tests shows true floating-point agent positions.
- All major code, logic, and documentation updates were generated by AI (Cascade).

## 2025-04-17 — Modernization and Documentation
- Refactored all imports to use Zig module/component references (no relative or file extension imports)
- Added comprehensive doc comments to all major modules: agent_type, terrain_effects, interaction_type, map, render_config, benchmark, etc.
- Cleaned up unused imports and clarified code structure
- Updated README.md with a modern overview and setup instructions
- Removed obsolete files: CLAUDE.md, CLAUDEMEM.md

## 2025-04-17 — Recent Refactors, Documentation, and Cleanup
- Refactored codebase for improved maintainability and extensibility
- Added comprehensive documentation for all major components
- Cleaned up code structure and removed unnecessary files

## 2025-04-17 — Modernization and Documentation
- Refactored all imports to use Zig module/component references (no relative or file extension imports)
- Added comprehensive doc comments to all major modules: agent_type, terrain_effects, interaction_type, map, render_config, benchmark, etc.
- Cleaned up unused imports and clarified code structure
- Updated README.md with a modern overview and setup instructions
- Removed obsolete files: CLAUDE.md, CLAUDEMEM.md

## Initial Project Setup and Fixes
- Fixed build.zig to use `.cwd_relative` instead of `.path` for Zig 0.14.0 compatibility
- Fixed syntax in agent.zig by adding proper braces around switch case statements
- Changed `var terrain` to `const terrain` in map.zig as the variable wasn't being mutated
- Verified build and run functionality

## Added Unit Tests
- Created test files for all major components (agent_test.zig, map_test.zig, simulation_test.zig)
- Implemented tests for agent creation, symbol mapping, and movement
- Implemented tests for map initialization, terrain access, and manipulation
- Implemented tests for simulation initialization, agent spawning, and updating

## Improved Agent Movement with Brownian Motion
- Replaced simple directional movement with Brownian motion for more natural random walks
- Implemented different energy costs based on agent type (Explorers move efficiently, Builders less so)
- Added proper boundary checking for movement

## Added Agent Interactions
- Implemented interaction system between nearby agents
- Created five interaction types: Greeting, Trading, Collaboration, Teaching, and Resource
- Added interaction duration and automatic expiration
- Different agent types prefer different interaction types
- Enhanced map display to show active interactions
- Agents don't move while interacting with each other
- Updated file saving to include interaction data

## Expanded Agent Types and Behaviors
- Added three new agent types: Farmer, Miner, and Scout
- Each agent type has unique movement patterns and energy costs
- Implemented agent-specific interaction preferences
- Different agent types have different health and energy distributions
- Agents interact differently with terrain based on their type
- Enhanced visualization with unique symbols and colors for each agent type

## Compatibility Fixes
- Adjusted code to work with Zig 0.14.0
- Fixed random number generation to use simpler timestamp-based approach
- Modified symbols to use ASCII characters for compatibility
- Optimized file and interaction display

## SDL3 Graphical Visualization
- Created renderer.zig with SDL3 integration
- Implemented color-coded terrain rendering with grid layout
- Added agent representation with different colors by type
- Added interaction visualization with connecting lines
- Maintained original ASCII output alongside graphical display
- Added configuration to switch between ASCII-only and SDL mode
- Added frame delay to control simulation speed
- Implemented input handling (pause, step, spawn, agent selection, exit)
- Added spawn mode allowing user to place agents with mouse clicks
- Enhanced visualization with agent-type selection controls

## SDL3 Integration and Compatibility
- Updated build.zig to properly link with SDL3 from Homebrew
- Fixed SDL3 API compatibility issues for SDL 3.2.x
- Updated renderer code to use new SDL3 types (SDL_FRect instead of SDL_Rect)
- Fixed keyboard event handling to use scancode-based input
- Updated mouse event handling to handle floating-point coordinates
- Fixed rendering calls to use SDL3's updated API
- Added helper script (run_gui.sh) to detect and use SDL3
- Made SDL3 support optional with fallback to text mode
- Added detailed debug output for SDL3 initialization
- Fixed integer division to use @divTrunc for signed integers

## Multi-threading and Performance Improvements
- Implemented multi-threaded agent updates using Zig's standard thread API
- Added mutex-protected access to interactions data for thread safety
- Created dynamic thread allocation based on agent count
- Added adaptive threading that falls back to single-threaded mode for small agent counts
- Implemented batch processing of agents across multiple threads
- Enhanced test suite to verify multi-threaded functionality
- Individual random seeds for each agent ensure unique movement patterns

## Benchmarking and Stress Testing
- Added benchmarking functionality (B key) to add 10 random agents
- Added stress testing functionality (S key) to add 100 random agents at once
- Implemented performance metrics tracking with updates per second display
- Added visual performance indicator in SDL mode showing FPS
- Enhanced simulation to run indefinitely instead of limiting to specific steps
- Optimized console output for long-running simulations
- Added clean single-line status updates to reduce terminal clutter

## User Interface Improvements
- Implemented keyboard controls for all simulation features
- Added mouse-based agent placement
- Created status panel with simulation info
- Added visual cursor feedback in agent placement mode
- Implemented dynamic UI elements that reflect simulation state
- Reduced console output to maximize performance
- Added informative status line with simulation statistics
- Added final map printing at program exit

## Code Refactoring and Organization
- Extracted interaction system into a dedicated module (interactions.zig)
- Created a separate terrain generation module (terrain.zig)
- Implemented a Movement struct to handle all directional movement logic
- Converted hardcoded movement patterns to a data-driven approach
- Replaced repetitive terrain effect logic with a lookup table approach
- Improved boundary checking and position calculation logic
- Added clear separation between data structures and behaviors
- Simplified health and energy management code
- Reduced code duplication across agent behavior functions
- Made the codebase more extensible for future improvements
- Added self-documenting code with improved naming conventions
- Split agent code into focused modules (agent.zig, agent_type.zig, movement.zig, terrain_effects.zig, interaction_type.zig)
- Reorganized project into logical directory structure (src/agents/, src/world/, tests/)
- Created proper build.zig file for managing dependencies

## Performance Testing and Optimization
- Created standalone perf_test.zig tool for measuring agent performance
- Achieved 169+ million agent updates per second in performance tests
- Fixed movement range checks to handle double-step moves correctly
- Optimized data structures for efficient memory use
- Implemented O(1) time complexity for agent movement calculations
- Added performance benchmarking with configurable agent counts and iterations
- Ensured all algorithms scale efficiently with increasing agent counts
- Added detailed statistics on movement patterns for verification

## Summary
The community simulation now features:
- Six agent types with unique behaviors: Settler, Explorer, Builder, Farmer, Miner, and Scout
- Random movement with unique patterns per agent based on individual seeds
- Five interaction types: Greeting, Trading, Collaboration, Teaching, and Resource
- Interactive controls via keyboard and mouse
- Performance benchmarking and stress testing capabilities
- Support for thousands of agents with multi-threaded processing
- Real-time performance metrics and statistics
- Dynamic terrain with procedurally generated features
- Dual visualization modes: ASCII terminal output and SDL3 graphical rendering
- Saving simulation state to file
- Configurable simulation speed and display options
- User-friendly interface with status indicators
- Comprehensive unit tests for all components
- Modular system architecture with clean separation of concerns
- Data-driven design for agent behavior configuration
- Optimized code organization for maintainability and extensibility
- High-performance code with 169+ million agent updates per second
- Detailed movement distribution statistics
- Clean, modular project structure with focused files

```zig
// Example of refactored movement calculation for agents
fn calculateMovement(self: *Agent) Movement {
    // Mix timestamp with agent's unique seed for random movement
    const timestamp = @as(u64, @bitCast(std.time.milliTimestamp()));
    // Create a simple random number by mixing the seed with timestamp and ID
    self.seed = (self.seed +% timestamp) *% 6364136223846793005 +% self.id;
    const random_value = self.seed;
    
    // Get this agent type's movement tendencies
    const tendency = self.type.getMovementTendency();
    
    // First check if the agent should move at all
    if (@mod(random_value, 100) >= tendency.move_chance) {
        return Movement.none();
    }
    
    // Determine if movement should be cardinal or diagonal
    var movement: Movement = undefined;
    if (tendency.all_direction_movement and @mod(random_value >> 8, 100) < 30) {
        // Diagonal movement (8 direction)
        const dir: u8 = @intCast(@mod(random_value >> 16, 4));
        movement = Movement.diagonal(dir);
    } else {
        // Cardinal movement (4 direction)
        const dir: u8 = @intCast(@mod(random_value >> 16, 4));
        movement = Movement.cardinal(dir);
    }
    
    // Special case for home tendency
    if (tendency.home_tendency > 0 and @mod(random_value >> 32, 20) < tendency.home_tendency) {
        // Pull toward a location determined by their ID
        const center_x = @mod(self.id * 7, 10);
        const center_y = @mod(self.id * 13, 10);
        
        // Adjust movement toward home
        if (self.x > center_x and @mod(random_value >> 40, 10) < tendency.home_tendency) {
            movement.dx = -1;
        } else if (self.x < center_x and @mod(random_value >> 40, 10) < tendency.home_tendency) {
            movement.dx = 1;
        }
        
        if (self.y > center_y and @mod(random_value >> 48, 10) < tendency.home_tendency) {
            movement.dy = -1;
        } else if (self.y < center_y and @mod(random_value >> 48, 10) < tendency.home_tendency) {
            movement.dy = 1;
        }
    }
    
    // Check for double step chance
    if (tendency.double_step_chance > 0 and @mod(random_value >> 24, 100) < tendency.double_step_chance) {
        movement = movement.scale(2);
    }
    
    return movement;
}